# CTSD
Computational Thinking &amp; System Design



## 2020-09-27

+ 完成Coursera第一周的课程

+ 需要修改权限才能运行脚本，之后可以创建软链接

  ~~~bash
  chmod +x HardwareSimulator.sh
  ~~~

+ 最大的坑：如果同一个文件夹里已经有Chip的话，会加载同一个文件夹里的Chip，而不是内置的Chip。所以我运行projects/demo/Xor.hdl没有问题，可是projects/01/Xor.hdl就会错。原因是因为01/Xor.hdl里面用了And，Or，Not，而这些当时还没被实现。demo里的能行得通因为调用了tools/builtinchips里面的。




## 2020-09-28

+ 不同的chip的实现，结果非常的不同。如何能化简为最简形式呢？
+ true和false可以自己改变长度，但是一个普通的01没法扩展到相应的位数。在Mux8Way16中就很麻烦，需要挨个给输入的16位的变量赋值。（应该有什么简写的方法）
+ 写到后来就跟函数调用感觉差不多了。但是让人隐约觉得可以化简，这样直接去套得到的性能很不放心。（真实的计算机组成的话，要考虑每个门的延迟时间。如果是这种串行的方法，机器的主频根本上不去）
+ 还是挺好玩的，真的挺有创造的感觉。这个一遍过的感觉比高级语言调包激动多了。
+ 如果用自己的芯片实现的底层，越到上面效率越可能爆炸。抛开实现的正确与否，模拟器不可能真正模拟硬件的并行等特性，所以如果不用内置好的算法，效率越到后面就会越慢。（不过还是让人很有冲动尝试下啊）
+ 实现了一个helper chip，Extendx系列。效果是将真值扩展为x位。如Extend16，输入为1个bit，值1，输出16个bit，每个都是1。（从实现上，取反要更简单，这也就是为什么要用Nand吧）
+ 应该如何正确地实现if的效果？？而不是把结果都算出来然后Mux。
+ 可以直接在命令行里运行测试，比图形界面快很多
+ internal pin是不能用sub_bus的，导致使用Or8Way的时候非常麻烦，所以又弄了一个Or16Way chip。
+ 如何从一个16bit中选择一位的值？Simulator不允许使用内部变量的sub_bus，也不能将外部输出进一步用于运算，导致这个问题变得非常麻烦。不过当然可能是我没想到好办法。

